{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Build your own Macro pad","text":"<p>We'll build our own macropad in this session. We'll mostly focus on learning to solder and putting everything together.</p> <p>The firmware part is also described, if writing software isn't your thing, ask for some help to get the final code on your device. It's located in the repository.</p>"},{"location":"#the-goal","title":"The goal","text":"<p>A functioning macropad with 6 customizable hotkeys and a clickable volume knob.</p>"},{"location":"#steps","title":"Steps","text":"<ol> <li>First we'll solder the headers on to the microcontroller.</li> <li>Required software setup.</li> <li>Next we can connect the rotary encoder and program it to work as a volume knob for our PC.</li> <li>Now the hard part, wiring up all of our keyboard switches.</li> <li>Then we have the assembly.</li> <li>And finally the finishing-touches!</li> </ol> <p>Good luck!</p>"},{"location":"assembly/","title":"Assembly","text":"<p>We've prepared all of our parts, soldered what needed soldering, now it's on to assembly!</p>"},{"location":"assembly/#install-keycaps","title":"Install keycaps","text":"<p>Choose some keycaps and press them firmly onto the switches.</p>"},{"location":"assembly/#install-the-knob","title":"Install the knob","text":"<p>The knob should be a tight fit, press it on firmly until it bottoms out.</p>"},{"location":"assembly/#plug-in-the-usb-cable","title":"Plug in the USB cable","text":"<p>You should know how to do this \ud83d\ude09.</p>"},{"location":"assembly/#close-it-up","title":"Close it up","text":"<p>Fit the bottom and top part of your macropad together, making sure there are no wires interfering. Then close the macropad using the 4 M3*8mm screws.</p> <p>Next up finishing touches.</p>"},{"location":"finishing-touches/","title":"Finishing touches","text":"<p>We're building a macro pad, not a tiny keyboard, so we still have to add some finishing touches to our software.</p> <p>In the code provided I've mapped the keys to:</p> <ul> <li>Open windows explorer</li> <li>Minimize all your windows</li> <li>Lock your PC</li> <li>Mute your microphone</li> <li>And 3 keys (F13, F14, F15) that are programmable</li> </ul>"},{"location":"finishing-touches/#extra-software","title":"Extra software","text":""},{"location":"finishing-touches/#mute-microphone","title":"Mute microphone","text":"<p>If you're using Windows 11, you're in luck. Map the key to <code>WIN+ALT+K</code> and your microphone should mute/unmute. If you're on Windows 10 however you can use Microsoft Powertoys to provide a shortcut for you (and lots, lots more!).</p>"},{"location":"finishing-touches/#autohotkey","title":"AutoHotKey","text":"<p>If you want complete flexibility, you can use the F13-F15 keys and program them using AutoHotkey.</p> Completed code <pre><code>import rotaryio\nimport board\nimport keypad\nimport neopixel\nimport usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keycode import Keycode\nfrom adafruit_hid.consumer_control import ConsumerControl\nfrom adafruit_hid.consumer_control_code import ConsumerControlCode\n\nencoder = rotaryio.IncrementalEncoder(board.D9, board.D10)\n\ncc = ConsumerControl(usb_hid.devices)\n\nbutton_state = None\nlast_position = encoder.position\n\nKEY_PINS = (\n    board.D1,\n    board.D2,\n    board.D3,\n    board.D4,\n    board.D5,\n    board.D6,\n    board.D7,  # Rotary encoder click\n)\n\nKEYCODES = (\n    [Keycode.WINDOWS, Keycode.E], # Open explorer\n    [Keycode.WINDOWS, Keycode.M], # Minimize all windows\n    [Keycode.WINDOWS, Keycode.L], # Lock your PC\n    [Keycode.F13], # Assignable in AutoHotKey\n    [Keycode.F14], # Assignable in AutoHotKey\n    [Keycode.F15], # Assignable in AutoHotKey\n    [Keycode.WINDOWS, Keycode.SHIFT, Keycode.A],  # PowerToys mute/unmute\n)\n\nON_COLOR = (0, 0, 255)\nOFF_COLOR = (0, 20, 0)\n\nkeys = keypad.Keys(KEY_PINS, value_when_pressed=False, pull=True)\nneopixel = neopixel.NeoPixel(board.NEOPIXEL, 1, brightness=0.4)\nneopixel.fill(OFF_COLOR)\nkbd = Keyboard(usb_hid.devices)\n\nwhile True:\n    event = keys.events.get()\n    if event:\n        key_number = event.key_number\n        # A key transition occurred.\n        if event.pressed:\n            kbd.send(*KEYCODES[key_number])\n            neopixel.fill(ON_COLOR)\n\n        if event.released:\n            neopixel.fill(OFF_COLOR)\n\n    current_position = encoder.position\n    position_change = current_position - last_position\n    if position_change &gt; 0:\n        for _ in range(position_change):\n            cc.send(ConsumerControlCode.VOLUME_INCREMENT)\n    elif position_change &lt; 0:\n        for _ in range(-position_change):\n            cc.send(ConsumerControlCode.VOLUME_DECREMENT)\n    last_position = current_position\n</code></pre>"},{"location":"rotary-encoder/","title":"Rotary encoder","text":"<p>A rotary encoder is a knob that sends a digital signal to our microcontroller if you turn it one way, and another signal if we turn it the other way. Perfect for our volume knob! You can press it as well, we'll use this to mute our microphone during meetings.</p> <p>In this section we'll wire up the rotary encoder and program it.</p>"},{"location":"rotary-encoder/#wiring","title":"Wiring","text":"<p>To wire the rotary encoder follow this diagram (my apologies for the non-existing paint skills \ud83d\ude05)</p> <p></p> <p>We'll connect the rotary encoder using the shorter (10cm) wires with 2 female plugs on the end.</p> <ul> <li> <code>GND</code> to <code>GND</code> pin</li> <li> <code>5V</code> to the <code>3V3</code> pin on the board (\u2757\u2757 NOT THE <code>5V</code> PIN \u2757\u2757)</li> <li> <code>S1</code> to <code>PIN 9</code></li> <li> <code>S2</code> to <code>PIN 10</code></li> <li> <code>KEY</code> to <code>PIN 7</code></li> </ul>"},{"location":"rotary-encoder/#firmware","title":"Firmware","text":"<p>We'll use the built-in <code>rotary-encoder</code> library to read out our encoder. Follow this tutorial to get the rotary encoder running.</p> Completed code <pre><code>import rotaryio\nimport board\nimport digitalio\nimport usb_hid\nfrom adafruit_hid.consumer_control import ConsumerControl\nfrom adafruit_hid.consumer_control_code import ConsumerControlCode\n\nbutton = digitalio.DigitalInOut(board.D12)\nbutton.direction = digitalio.Direction.INPUT\nbutton.pull = digitalio.Pull.UP\n\nencoder = rotaryio.IncrementalEncoder(board.D10, board.D9)\n\ncc = ConsumerControl(usb_hid.devices)\n\nbutton_state = None\nlast_position = encoder.position\n\nwhile True:\n    current_position = encoder.position\n    position_change = current_position - last_position\n    if position_change &gt; 0:\n        for _ in range(position_change):\n            cc.send(ConsumerControlCode.VOLUME_INCREMENT)\n        print(current_position)\n    elif position_change &lt; 0:\n        for _ in range(-position_change):\n            cc.send(ConsumerControlCode.VOLUME_DECREMENT)\n        print(current_position)\n    last_position = current_position\n    if not button.value and button_state is None:\n        button_state = \"pressed\"\n    if button.value and button_state == \"pressed\":\n        print(\"Button pressed.\")\n        cc.send(ConsumerControlCode.PLAY_PAUSE)\n        button_state = None\n</code></pre> <p>Next up installing and programming our keyboard switches.</p>"},{"location":"software-setup/","title":"Software setup","text":"<p>In this section we'll set up the software we need for this project, and we'll make the built-in LED blink. The hardware equivalent of <code>Hello world!</code>.</p>"},{"location":"software-setup/#downloads","title":"Downloads","text":"<ul> <li>Mu Editor The IDE we'll use to program our macropad</li> <li>CircuitPython runtime The CircuitPython runtime for our board</li> <li>CircuitPython Essentials Grab the latest release here and unzip it on your PC. Make sure you get the <code>8.x-mpy</code> version.</li> </ul>"},{"location":"software-setup/#initial-setup","title":"Initial Setup","text":"<p>Follow the guide here until you can blink the built-in LED. After this you should be able to get new code on your board and run it.</p> <p>You'll have to reset the board using the two <sub>tiny</sub> buttons, then drag the downloaded runtime onto the board (it shows up as an external drive). It should reboot immediately and show up as a drive called <code>CIRCUITPY</code>. If this worked, you're ready to open up the Mu editor!</p> <p>Try to run the code from the tutorial, and hopefully, watch the blinking lights!</p>"},{"location":"software-setup/#installing-libraries-from-circuitpython-essentials","title":"Installing libraries from CircuitPython essentials","text":"<p>To install some of the libraries we're going to use, drag them into the <code>lib</code> folder on the <code>CIRCUITPY</code> external drive. You can find them in the CircuitPython Essentials folder you've unzipped previously. We'll need two libraries:</p> <ul> <li>The <code>adafruit_hid</code> folder</li> <li>The <code>neopixel.mpy</code> file</li> </ul> <p>Next up Wiring and programming the rotary encoder!</p>"},{"location":"solder-headers/","title":"Soldering the headers","text":"<p>You'll be divided up into groups, each with their own soldering iron and some basic tools.</p> <p>We'll need to solder pin headers to our microcontroller, and wires to each of our keyboard switches.</p>"},{"location":"solder-headers/#the-microcontroller","title":"The microcontroller","text":"<p>In this project we'll be using (a tiny!) microcontroller based on the RP2040 chip by Raspberry Pi. Their default board is a bit big for this project though, so we use a tiny board with the same chip on it. The XIAO RP2040.</p> <p>To make it a bit easier on ourselves (it'll be hard enough already \ud83d\ude03) we'll start by soldering headers onto our board.</p> <p>These are tiny pins we can plug things into later.</p> <p></p> <p>Start by making sure you've got 2 rows of 7 pins. Then we'll fit these onto our board, and then stick this upside down onto a breadboard.</p> <p></p> <p></p> <p>Once the board and headers are firmly in their place we'll solder all 14 pins. I'll come by to get everyone started, but make sure to have a look at this short guide.</p> <p></p> <p></p> <p>Next up installing the required software, and making an LED blink!</p>"},{"location":"switches/","title":"The keyboard switches","text":"<p>Each macropad has 6 keyboard switches found in mechanical keyboards (you too can annoy your coworkers starting right now!). In this section we'll solder some wire to them, connect them to the board and make it act as a tiny keyboard.</p>"},{"location":"switches/#soldering","title":"Soldering","text":"<p>Each one of these switches needs 2 wires soldered to them.</p> <p>First we'll prepare the wires, grab 6 of the long jumper wires and cut them in 3 pieces.</p> <p></p> <p>Next we'll strip the wires, you should have 12 in total. Now we'll solder the wires to our switches, this can be a bit tricky. I like to fold a small loop on the end of the stripped wire and then hook it over the pin of the switch and hold it in place with helping hands or tweezers.</p> <p></p> <p></p> <p></p>"},{"location":"switches/#wiring-it-up","title":"Wiring it up","text":"<p>Follow the wiring diagram to connect everything together. Every keyboard switch should have one pin going to the common ground (bottom of the image) and one pin to the microcontroller (pins 0 to 5).</p> <p></p>"},{"location":"switches/#firmware","title":"Firmware","text":"<p>To read all of our key inputs we'll be using the keypad built-in library of CircuitPython.</p> <p>Read this tutorial up to the second page, we'll base our code on their example. Our keys are set up a bit differently though, so I'll help you with the setup code:</p> <pre><code>KEY_PINS = (\n    board.D1,\n    board.D2,\n    board.D3,\n    board.D4,\n    board.D5,\n    board.D6,\n    board.D7 # Rotary encoder click\n)\n\nKEYCODES = (\n    Keycode.ONE,\n    Keycode.TWO,\n    Keycode.THREE,\n    Keycode.FOUR,\n    Keycode.FIVE,\n    Keycode.SIX,\n    Keycode.SEVEN\n)\n</code></pre> <p>The built in neopixel is a bit different as well, we only have the one.</p> <pre><code>neopixel = neopixel.NeoPixel(board.NEOPIXEL, 1, brightness=0.4)\nneopixel.fill(OFF_COLOR)\n</code></pre> <p>And instead of lighting up a specific NeoPixel, we'll always light up our single one. Replace <code>neopixels[key_number] = ON_COLOR</code> with <code>neopixel.fill(ON_COLOR)</code>.</p> <p>If everything works out, you should have a tiny keyboard that sends the keys from 1 to 6, and the built in LED changes colour when a key is pressed.</p> Completed code <pre><code>import rotaryio\nimport board\nimport keypad\nimport neopixel\nimport usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keycode import Keycode\nfrom adafruit_hid.consumer_control import ConsumerControl\nfrom adafruit_hid.consumer_control_code import ConsumerControlCode\n\nencoder = rotaryio.IncrementalEncoder(board.D9, board.D10)\n\ncc = ConsumerControl(usb_hid.devices)\n\nbutton_state = None\nlast_position = encoder.position\n\nKEY_PINS = (\n    board.D1,\n    board.D2,\n    board.D3,\n    board.D4,\n    board.D5,\n    board.D6,\n    board.D7 # Rotary encoder click\n)\n\nKEYCODES = (\n    Keycode.ONE,\n    Keycode.TWO,\n    Keycode.THREE,\n    Keycode.FOUR,\n    Keycode.FIVE,\n    Keycode.SIX,\n    Keycode.SEVEN\n)\n\nON_COLOR = (0, 0, 255)\nOFF_COLOR = (0, 20, 0)\n\nkeys = keypad.Keys(KEY_PINS, value_when_pressed=False, pull=True)\nneopixel = neopixel.NeoPixel(board.NEOPIXEL, 1, brightness=0.4)\nneopixel.fill(OFF_COLOR)\nkbd = Keyboard(usb_hid.devices)\n\nwhile True:\n    event = keys.events.get()\n    if event:\n        key_number = event.key_number\n        # A key transition occurred.\n        if event.pressed:\n            kbd.press(KEYCODES[key_number])\n            neopixel.fill(ON_COLOR)\n\n        if event.released:\n            kbd.release(KEYCODES[key_number])\n            neopixel.fill(OFF_COLOR)\n\n    current_position = encoder.position\n    position_change = current_position - last_position\n    if position_change &gt; 0:\n        for _ in range(position_change):\n            cc.send(ConsumerControlCode.VOLUME_INCREMENT)\n    elif position_change &lt; 0:\n        for _ in range(-position_change):\n            cc.send(ConsumerControlCode.VOLUME_DECREMENT)\n    last_position = current_position\n</code></pre> <p>Next up assembly!</p>"}]}